/**
 * @author     LiuZhaoHui <hi.liuzhaoxin@gmail.com>
 * @link       http://www.eatbean.com/nodejs
**/

"use strict";

var mc = Dew("use", "DataBase.Memcached");
var Multipart = Dew("use", "Server.Web.Request.Form.Multipart");
var Urlencoded = Dew("use", "Server.Web.Request.Form.Urlencoded");

var HttpForm = 
{
    __name__ : "HttpForm", 
    
    _isError : false, 
    _fileCount : 0, 
    _bytesReceived : 0, 
    _bytesExpected : -1, 
    
    _emptyFunction : new Function (), 
    
    initialize : function (application)
    {
        application.useSection("paths");
        
        // 上传临时目录
        this._uploadTmpDir = application.get("startupPath") + "/" 
          + application.get("uploadPath");
        
        application.useSection("http");
        
        // 是否允许解析表单
        this._allowForm = application.get("allow_form");
        
        // 最大上传时间
        this._maxInputTime = application.get("max_input_time") * 1000;
        
        // 最大上传文件数量
        this._maxFileUploads = application.get("max_file_uploads");
        
        // 最大上传字节
        this._postMaxFilesize = application.get("post_max_filesize");
        
        if (application.get("clear_upload_directory"))
        {
            var fs = require("fs");
            var now = new Date();
            var dir = this._uploadTmpDir;
            
            // 清理24小时前的临时文件
            now.setDate(now.getDate() - 1);
            
            fs.readdirSync(dir).forEach(function (v, i)
            {
                var	file = dir + "/" + v;
                var info = fs.statSync(file);
                
                now > info.mtime && fs.unlink(file);
            });
        }
        
        mc.initialize(application);
        Multipart.initialize(HttpForm);
    }, 
    
    // 返回一个 HttpForm 实例
    getInstance : function (async, route, request, response)
    {
        var self = Object.create(this);
        self._async = async;
        self._route = route;
        self._request = request;
        //self._response = response;
        
        if (!this._allowForm || !self.setParser_())
        {
            return async.next();
        }
        
        if ("content-length" in request.headers)
        {
            self._bytesExpected = parseInt(request.headers["content-length"]);
        }
        
        request.requestContext.on("data", this.write_.bind(self)).on("end", this.finish_.bind(self));
        
        if ("progress_key" in request.querys)
        {
            self._progressKey = request.querys.progress_key;
        }
        
        self._timeout = +new Date() + this._maxInputTime;
        
        return self;
    }, 
    
    setParser_ : function ()
    {
        if (!("content-type" in this._request.headers))
        {
            console.log("bad content-type header, no content-type");
            
            return false;
        }
        
        var type = this._request.headers["content-type"];
        
        if (~type.lastIndexOf("urlencoded"))
        {
            this._parser = Urlencoded.getInstance(this._request);
        }
        else if (~type.lastIndexOf("multipart"))
        {
            if (!("allow" in this._route && ~this._route.allow.indexOf("upload")))
            {
                return false;
            }
            
            var offset = type.lastIndexOf("boundary=");
            
            if (~offset)
            {
                this._parser = Multipart.getInstance(this, type.slice(offset + 9));
            }
            else
            {
                console.log("bad content-type header, no multipart boundary");
                
                return false;
            }
        }
        else
        {
            console.log("bad content-type header, unknown content-type: " + type);
            
            return false;
        }
        
        return true;
    }, 
    
    progress_ : function ()
    {
        mc.set(this._progressKey, "{\"received\":" + this._bytesReceived 
          + ",\"expected\":" + this._bytesExpected + "}", this._emptyFunction, 8);
    }, 
    
    write_ : function (chunk)
    {
        var length = chunk.length;
        var bytesParsed = this._parser.write(chunk, length);
        
        this._bytesReceived += length;
        
        if (bytesParsed !== length)
        {
            console.log("parser error, " + bytesParsed + " of " + length + " bytes parsed");
        }
        else if (this._postMaxFilesize < this._bytesReceived)
        {
            console.log("maxFieldsSize exceeded, received " + this._bytesReceived + " bytes of field data");
        }
        else if (this._timeout < new Date())
        {
            console.log("maxParseTime exceeded");
        }
        else if (this._maxFileUploads < this._fileCount)
        {
            console.log("max file uploads exceeded");
        }
        else
        {
            "_progressKey" in this && this.progress_();
            return;
        }
        
        this.error_();
    }, 
    
    finish_ : function ()
    {
        // 如果发生错误，那么就不执行 parser.end 方法
        !this._isError && this._parser.end();
        
        this._async.next();
    }, 
    
    error_ : function ()
    {
        this._isError = true;
        this._parser.error();
        
        this._request.requestContext.removeAllListeners("data");
        this._request.requestContext.emit("end");
    }
};

module.exports = HttpForm;