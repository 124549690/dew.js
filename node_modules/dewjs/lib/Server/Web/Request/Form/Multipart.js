/**
 * @author     LiuZhaoHui <hi.liuzhaoxin@gmail.com>
 * @link       http://www.eatbean.com/nodejs
**/

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// https://github.com/felixge/node-formidable
// reference "multipart_parser.js" file section content
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

"use strict";

var PostedFile = Dew("use", "Server.Web.Request.Form.PostedFile");

var Multipart = 
{
    __name__ : "Multipart", 
    
    _A : 
    {
        LF : 0x0A,			// 换行
        CR : 0x0D,			// 回车
        SPACE : 0x20,		// 空格
        HYPHEN : 0x2D,	// 横线
        COLON : 0x3A,		// 冒号
        A : 0x61,
        Z : 0x7A
    }, 
    
    _F : 
    {
        PART_BOUNDARY : 1, 
        LAST_BOUNDARY : 2
    }, 
    
    _S : 
    {
        START : 0, 
        START_BOUNDARY : 1, 
        HEADER_FIELD_START : 2, 
        HEADER_FIELD : 3, 
        HEADER_VALUE_START : 4, 
        HEADER_VALUE : 5, 
        HEADER_VALUE_ALMOST_DONE : 6, 
        HEADERS_ALMOST_DONE : 7, 
        PART_DATA_START : 8, 
        PART_DATA : 9, 
        END : 10
    }, 
    
    _type : -1, 
    TYPE_FILE : 0, 
    TYPE_FIELDS : 1, 
    
		_index : 0, 
		_flags : 0, 
		_state : 0, 
    
		_headerField : "", 
		_headerValue : "", 
    
    //_writeCount : 1, 
    
    initialize : function (httpForm)
    {
        PostedFile.initialize(httpForm);
    }, 
    
    // 返回一个 Multipart 实例
    getInstance : function (httpForm, boundary)
    {
        var self = Object.create(this);
        self._files = {};
        self._fields = {};
        self._boundary = new Buffer("\r\n--" + boundary);
        self._lookbehind = new Buffer(self._boundary.length + 6);
        
        self._httpForm = httpForm;
        self._request = httpForm._request;
        //self._requestContext = self._request.requestContext;
        //self._response = httpForm._response;
        
        return self;
    }, 
    
    write : function (chunk, len)
    {
        //this._requestContext.pause();
        
        var A = this._A, S = this._S, F = this._F;
        var index = this._index, prevIndex = index;
        var flags = this._flags, lookbehind = this._lookbehind;
        var boundary = this._boundary, boundaryLength = boundary.length;
        var state = this._state, mark = 0;
        var i = 0, ord, c;
        
        for (; i < len; i++)
        {
            ord = chunk[i];
            switch (state)
            {
                case S.START : 
                  index = 0;
                  state = S.START_BOUNDARY;
                  
                case S.START_BOUNDARY : 
                  if (index === boundaryLength - 2)
                  {
                      if (ord !== A.CR)
                      {
                          return i;
                      }
                  }
                  else if (index === boundaryLength - 1)
                  {
                      if (ord !== A.LF)
                      {
                          return i;
                      }
                      state = S.HEADER_FIELD_START;
                      break;
                  }
                  else if (ord !== boundary[index + 2])
                  {
                      return i;
                  }
                  index++;
                  break;
                  
                case S.HEADER_FIELD_START : 
                  mark = i;
                  index = 0;
                  state = S.HEADER_FIELD;
                  
                case S.HEADER_FIELD : 
                  if (ord === A.CR)
                  {
                      state = S.HEADERS_ALMOST_DONE;
                      break;
                  }
                  index++;
                  if (ord === A.HYPHEN)
                  {
                      break;
                  }
                  else if (ord === A.COLON)
                  {
                      if (index === 1)
                      {
                          return i;
                      }
                      state = S.HEADER_VALUE_START;
                      this._headerField += chunk.toString("ascii", mark, i);
                      break;
                  }
                  c = ord | 0x20;
                  if (c < A.A && c > A.Z)
                  {
                      return i;
                  }
                  break;
                  
                case S.HEADER_VALUE_START : 
                  if (ord === A.SPACE)
                  {
                      break;
                  }
                  mark = i;
                  state = S.HEADER_VALUE;
                  
                case S.HEADER_VALUE : 
                  if (ord === A.CR)
                  {
                      this._headerValue += chunk.toString("ascii", mark, i);
                      this.handleHeaer_();
                      state = S.HEADER_VALUE_ALMOST_DONE;
                  }
                  break;
                  
                case S.HEADER_VALUE_ALMOST_DONE : 
                  if (ord !== A.LF)
                  {
                      return i;
                  }
                  state = S.HEADER_FIELD_START;
                  break;
                  
                case S.HEADERS_ALMOST_DONE : 
                  if (ord !== A.LF)
                  {
                      return i;
                  }
                  state = S.PART_DATA_START;
                  break;
                  
                case S.PART_DATA_START : 
                  mark = i;
                  state = S.PART_DATA;
                  
                case S.PART_DATA : 
                  prevIndex = index;
                  if (index === 0)
                  {
                      next:
                      while (i + boundaryLength < len)
                      {
                          ord = chunk[i + boundaryLength];
                          while (index < boundaryLength)
                          {
                              if (ord === boundary[index++])
                              {
                                  break next;
                              }
                          }
                          index = 0;
                          i += boundaryLength;
                      }
                      index = 0;
                      ord = chunk[i];
                  }
                  if (index < boundaryLength)
                  {
                      if (ord === boundary[index])
                      {
                          if (index++ === 0)
                          {
                              this.handleData_(chunk, mark, i);
                          }
                      }
                      else
                      {
                          index = 0;
                      }
                  }
                  else if (index === boundaryLength)
                  {
                      index++;
                      if (ord === A.CR)
                      {
                          flags |= F.PART_BOUNDARY;
                      }
                      else if (ord === A.HYPHEN)
                      {
                          flags |= F.LAST_BOUNDARY;
                      }
                      else
                      {
                          index = 0;
                      }
                  }
                  else if (index - 1 === boundaryLength)
                  {
                      if (flags & F.PART_BOUNDARY)
                      {
                          index = 0;
                          if (ord === A.LF)
                          {
                              flags &= ~F.PART_BOUNDARY;
                              state = S.HEADER_FIELD_START;
                              break;
                          }
                      }
                      else if (flags & F.LAST_BOUNDARY)
                      {
                          if (ord === A.HYPHEN)
                          {
                              state = S.END;
                          }
                          else
                          {
                              index = 0;
                          }
                      }
                      else
                      {
                          index = 0;
                      }
                  }
                  if (index > 0)
                  {
                      lookbehind[index] = ord;
                  }
                  else if (prevIndex > 0)
                  {
                      this.handleData_(lookbehind, 1, prevIndex + 1);
                      prevIndex = 0;
                      mark = i--;
                  }
                  break;
                  
                case S.END : 
                  break;
                  
                default : 
                  return i;
            }
        }
        
        if (state === S.HEADER_FIELD)
        {
            this._headerField += chunk.toString("ascii", mark, len);
        }
        else if (state === S.HEADER_VALUE)
        {
            this._headerValue += chunk.toString("ascii", mark, len);
        }
        else if (state === S.PART_DATA && index === 0)
        {
            this.handleData_(chunk, mark, len);
        }
        
        this._index = index;
        this._state = state;
        this._flags = flags;
        
        return i;
    }, 
    
    handleHeaer_ : function ()
    {
        if ("Content-Disposition" === this._headerField)
        {
            var offset = this._headerValue.indexOf("name=\""), index;
            
            if (~offset)
            {
                index = offset + 6;
                offset = this._headerValue.indexOf("\"", index);
                this._name = this._headerValue.slice(index, offset);
            }
            
            offset = this._headerValue.indexOf("filename=\"", offset);
            
            if (~offset)
            {
                index = offset + 10;
                offset = this._headerValue.indexOf("\"", index);
                
                this._type = this.TYPE_FILE;
                this._httpForm._fileCount++;
                this._files[this._name] = PostedFile.getInstance(this, this._headerValue.slice(index, offset));
            }
            else
            {
                this._type = this.TYPE_FIELDS;
                this._fields[this._name] = "";
            }
        }
        else if ("Content-Type" === this._headerField && this.TYPE_FILE == this._type)
        {
            this._files[this._name]._contentType = this._headerValue;
        }
        
        this._headerField = "";
        this._headerValue = "";
    }, 
    
    handleData_ : function (buf, start, end)
    {
        if (this.TYPE_FIELDS === this._type)
        {
            this._fields[this._name] += buf.toString("ascii", start, end);
        }
        else if (this.TYPE_FILE == this._type)
        {
            //this._writeCount--;
            this._files[this._name].write_(buf.slice(start, end), end - start);
        }
    }, 
    
    end : function ()
    {
        var files = this._files, name;
        
        for (name in files)
        {
            files[name].end_();
        }
        
        this._request._files = files;
        this._request._posts = this._fields;
        
        //this._response.on("finish", this.destroy_.bind(this));
    }, 
    
    error : function ()
    {
        var files = this._files, name;
        
        for (name in files)
        {
            files[name].end_();
            files[name].destroy_();
        }
    }, 
    
    destroy_ : function ()
    {
        for (var name in this._files)
        {
            this._files[name].destroy_();
        }
    }
};

module.exports = Multipart;