/**
 * @author     LiuZhaoHui <hi.liuzhaoxin@gmail.com>
 * @link       http://www.eatbean.com/nodejs
**/

"use strict";

var fs = require("fs");

var Queue = Dew("use", "Common.Queue");
var LString = Dew("use", "Lang.LString");
var UglifyJS = Dew("use", "Tool.UglifyJS.uglify-js");

var Attr = Dew("use", "Server.Web.View.Engine.Attr");
var Strip = Dew("use", "Server.Web.View.Engine.Strip");

var Compiler = 
{
    __name__ : "Compiler", 
    
    _defaultAssignName : "_T_", 
    _defaultCycleName : "_CY_", 
    _defaultLoopName : "_L_", 
    _defaultForName : "_F_", 
    _defaultEachName : "_E_", 
    
    _defaultCycleDelimiter : ",", 
    
    _cycleIndex : 0, 
    _loopIndex : 0, 
    _forIndex : 0, 
    _eachIndex : 0, 
    
    _counter : 0, 
    _counterStep : 1, 
    _counterDirection : 1, // 0 down, 1 up
    
    _eachStart : 0, 
    _eachStep : 1, 
    
    _forStart : 0, 
    _forStep : 1, 
    
    _callFunctionList : 
    {
        link : "_LINK_.assemble(#code#)", 
        page : "_PAGE_.getInstance(#code#).output()"
    }, 
    
    A : 
    {
        COMMA : 0x2C,		// 逗号 ,
        LBRACKET : 0x5B, // [
        RBRACKET : 0x5D, // ]
        SQUOTE : 0x22,	// 双引号 "
        DQUOTE : 0x27,	// 单引号 '
        SPACE : 0x20,		// 空格
        TAB : 0x09,			// 制表符
    }, 
    
    T : 
    {
        OUTPUT : 0, 
        ECHO : 1, 
        ASSIGN : 2, 
        CODE : 3, 
        DECLARE : 4, 
        BEFORE_ASSIGN : 5
    }, 
    
    S : 
    {
        CAPTURE : 0, 
        LITERAL : 1, 
        ELSEIF : 2, 
        ELSE : 3, 
        LOOP : 4, 
        EACH : 5, 
        FOR : 6
    }, 
    
    initialize : function (application)
    {
        Strip.initialize(application);
    }, 
    
    // 返回一个 Compiler 实例
    getInstance : function (directory, fileName)
    {
        var self = Object.create(this);
        self._directory = directory;
        self._fileName = fileName;
        
        self._if = [];
        self._ifRule = [];
        
        self._capture = [];
        self._captureRule = [];
        
        self._loop = [];
        self._loopRule = [];
        
        self._for = [];
        self._forRule = [];
        
        self._each = [];
        self._eachRule = [];
        
        self._assign = new Queue(this._defaultAssignName);
        self._context = [{type : this.T.ASSIGN, assign : this._defaultAssignName, value : "\"\""}];
        
        return self;
    }, 
    
    returnJS : function ()
    {
        this.parseTPL_(Strip.getInstance(this.getTplData_(this._fileName), this.getTplPath_(this._fileName)));
        
        this._ifRule.length && this.throwError_(this._ifRule.shift());
        this._captureRule.length && this.throwError_(this._captureRule.shift());
        this._loopRule.length && this.throwError_(this._loopRule.shift());
        this._forRule.length && this.throwError_(this._forRule.shift());
        this._eachRule.length && this.throwError_(this._eachRule.shift());
        
        var T = this.T;
        var varStack = [], code = "";
        var context = this._context, item;
        var i = 0, len = context.length;
        
        var beforeType = -1, beforeAssign = "";
        
        for (; i < len; i++)
        {
            item = context[i];
            
            if (item.type === T.OUTPUT)
            {
                if (beforeType === T.OUTPUT)
                {
                    if (beforeAssign === item.assign)
                    {
                        code += LString.quote(item.data);
                    }
                    else
                    {
                        code += "\";" + item.assign + "+=\"" + LString.quote(item.data);
                    }
                }
                else if (beforeType === T.ECHO)
                {
                    if (beforeAssign === item.assign)
                    {
                        code += "+\"" + LString.quote(item.data);
                    }
                    else
                    {
                        code += ";" + item.assign + "+=\"" + LString.quote(item.data);
                    }
                }
                else
                {
                    code += item.assign + "+=\"" + LString.quote(item.data);
                }
                
                beforeType = item.type;
                beforeAssign = item.assign;
                continue;
            }
            else if (item.type === T.ECHO)
            {
                if (beforeType === T.ECHO)
                {
                    if (beforeAssign === item.assign)
                    {
                        code += "+" + item.code;
                    }
                    else
                    {
                        code += ";" + item.assign + "+=" + item.code;
                    }
                }
                else if (beforeType === T.OUTPUT)
                {
                    if (beforeAssign === item.assign)
                    {
                        
                        code += "\"+" + item.code;
                    }
                    else
                    {
                        code += "\";" + item.assign + "+=" + item.code;
                    }
                }
                else
                {
                    code += item.assign + "+=" + item.code;
                }
                
                beforeType = item.type;
                beforeAssign = item.assign;
                continue;
            }
            
            if (beforeType === T.OUTPUT)
            {
                code += "\";"
            }
            else if (beforeType === T.ECHO)
            {
                code += ";";
            }
            
            beforeType = item.type;
            
            if (item.type === T.CODE)
            {
                code += item.code;
            }
            else if (item.type === T.ASSIGN)
            {
                code += item.assign + "=" + item.value + ";";
                !~varStack.indexOf(item.assign) && varStack.push(item.assign);
            }
            else if (item.type === T.DECLARE)
            {
                !~varStack.indexOf(item.assign) && varStack.push(item.assign);
            }
            else if (item.type === T.BEFORE_ASSIGN)
            {
                code = item.assign + "=" + item.value + ";" + code;
                !~varStack.indexOf(item.assign) && varStack.push(item.assign);
            }
        }
        
        if (beforeType === T.OUTPUT)
        {
            code += "\";"
        }
        else if (beforeType === T.ECHO)
        {
            code += ";";
        }
        
        // console.log("var " + varStack.join(",") + ";" + code)
        
        return "var " + varStack.join(",") + ";with(this){" + UglifyJS(code) 
          + ";return " + this._defaultAssignName + "}";
    }, 
    
    parseTPL_ : function (list)
    {
        var T = this.T;
        var cmd, item, index;
        
        while (item = list.nextToken())
        {
            if (item.type === list.T.HTML)
            {
                this._context.push({type : T.OUTPUT, assign : this._assign.current, data : item.value});
            }
            else if (item.type === list.T.TPL)
            {
                index = Math.max(item.value.indexOf(" "), item.value.indexOf("\t"));
                cmd = ~index ? item.value.slice(0, index) : item.value;
                
                switch (cmd)
                {
                    case "comment" : 
                      break;
                      
                    case "include" : 
                      this.include_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "echo" : 
                      this.echo_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "config" : 
                      this.config_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "assign" : 
                      this.assign_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "counter" : 
                      this.counter_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "cycle" : 
                      this.cycle_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "literal" : 
                      this.literal_(item, list);
                      break;
                      
                    case "endliteral" : 
                      this.endliteral_(item);
                      break;
                      
                    case "capture" : 
                      this.capture_(item, item.value.slice(index + 1).trimLeft());
                      break;
                    
                    case "endcapture" : 
                      this.endcapture_(item);
                      break;
                      
                    case "if" : 
                      this.if_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "elseif" : 
                      this.elseif_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "else" : 
                      this.else_(item);
                      break;
                      
                    case "endif" : 
                      this.endif_(item);
                      break;
                      
                    case "loop" : 
                      this.loop_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "endloop" : 
                      this.endloop_(item);
                      break;
                      
                    case "for" : 
                      this.for_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "endfor" : 
                      this.endfor_(item);
                      break;
                      
                    case "each" : 
                      this.each_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "endeach" : 
                      this.endeach_(item);
                      break;
                      
                    case "lang" : 
                      this.lang_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    case "function" : 
                      this.function_(item, item.value.slice(index + 1).trimLeft());
                      break;
                      
                    default : 
                      this.throwError_(item);
                }
            }
        }
    }, 
    
    /**
     * header.tpl
     * <html>
     * <head><title>dew</title></head>
     * <body>
     * 
     * footer.tpl
     * </body>
     * </html>
     * 
     * loop.tpl
     * <li>data...</li>
     * 
     * {tpl:include file="header.tpl"}
     * data...
     * {tpl:include file="footer.tpl"}
     * output: 
     * <html>
     * <head><title>dew</title></head>
     * <body>
     * data...
     * </body>
     * </html>
     * 
     * {tpl:include file="header.tpl"}
     * {tpl:include assign=loop file="loop.tpl"}
     * {tpl:echo loop}
     * {tpl:echo loop, loop}
     * {tpl:include file="footer.tpl"}
     * output: 
     * <html>
     * <head><title>dew</title></head>
     * <body>
     * data...
     * data...
     * data...
     * </body>
     * </html>
    **/
    include_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        !("file" in attr) && this.throwError_(rule);
        
        var file = attr.file.slice(1, -1);
        
        if ("assign" in attr)
        {
            this._assign.push(attr.assign);
            this._context.push
            ({
                type : this.T.ASSIGN, 
                assign : attr.assign, 
                value : "\"\""
            });
        }
        
        this.parseTPL_(Strip.getInstance(this.getTplData_(file), this.getTplPath_(file)));
        "assign" in attr && this._assign.pop();
    }, 
    
    /**
     * contact.json: {"name" : "lzx", "email" : "hi.liuzhaoxin@gmail.com"}
     * 
     * {tpl:echo contact.name, ":", contact["email"]}
     * output: 
     * lzx:hi.liuzhaoxin@gmail.com
    */
    echo_ : function (rule, expr)
    {
        var A = this.A;
        var i = 0, len = expr.length;
        var ch, flags;
        var ret = "", stack = [];
        var index = 0, start = 0, end = 0;
        
        for (; i < len; i++)
        {
            ch = expr.charCodeAt(i);
            
            if (index === 0)
            {
                start = i;
                index = 1;
            }
            
            if (index === 1)
            {
                if (ch === A.SQUOTE || ch === A.DQUOTE)
                {
                    index = 2;
                    flags = ch;
                    continue;
                }
                else if (ch === A.LBRACKET)
                {
                    index = 3;
                    
                    stack.push(ch);
                }
                else if (ch === A.COMMA)
                {
                    index = 0;
                    
                    ret += expr.slice(start, i) + "+";
                }
            }
            // "abc'
            else if (index === 2)
            {
                if (ch === A.BACKSLASH)
                {
                    index = flags;
                    flags |= ~flags;
                }
                else if (ch === flags)
                {
                    index = 1;
                    flags = 0;
                }
                else if (flags === -1)
                {
                    flags = index;
                }
            }
            else if (index === 3)
            {
                if (ch === A.LBRACKET)
                {
                    stack.push(ch);
                }
                else if (ch === A.RBRACKET)
                {
                    stack.shift() !== A.LBRACKET && this.throwError_(rule);
                }
                
                if (stack.length === 0)
                {
                    index = 1;
                    flags = 0;
                }
            }
        }
        
        if (index === 1)
        {
            ret += expr.slice(start);
        }
        else
        {
            this.throwError_(rule);
        }
        
        this._context.push({type : this.T.ECHO, assign : this._assign.current, code : ret});
    }, 
    
    /**
     * author.json:
     * {
     *     "name" : "lzx", "gender" : "male", "age" : 23, 
     *     "other" : {"address": "china"}
     * }
     * 
     * {tpl:config assign=author file="author.json"}
     * {tpl:echo "name: ", author.name, "; age: ", author.age, "; gender: ", author.gender}
     * output:
     * name: lzx; age: 23; gender: male
     * 
     * {tpl:config assign=other file="author.json" section="other"}
     * {tpl:echo "address: ", other.address}
     * output:
     * address: china
    **/
    config_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        !("file" in attr && "assign" in attr) && this.throwError_(rule);
        
        this._context.push
        ({
            type : this.T.DECLARE, 
            assign : attr.assign
        });
        
        var section = "";
        
        if ("section" in attr)
        {
            var ch = attr.section.charCodeAt();
            if (ch === this.A.SQUOTE || ch === this.A.DQUOTE)
            {
                section = "." + attr.section.slice(1, -1);
            }
            else
            {
                section = "[" + attr.section + "]";
            }
        }
        
        this._context.push
        ({
            type : this.T.CODE, 
            code : "_CONF_.use(" + attr.file + ");" + attr.assign + "=_CONF_.current" + section + ";"
        });
    }, 
    
    /**
     * {tpl:assign name=address value="chian"}
     * {tpl:echo address}
     * output: 
     * chian
    **/
    assign_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        !("name" in attr && "value" in attr) && this.throwError_(rule);
        
        this._context.push
        ({
            type : this.T.ASSIGN, 
            assign : attr.name, 
            value : attr.value
        });
    }, 
    
    /**
     * {tpl:counter}
     * {tpl:counter}
     * {tpl:counter assign=timer}
     * {tpl:echo timer}
     * output: 
     * 1
     * 2
     * 2
     * 
     * {tpl:counter step=3}
     * {tpl:counter}
     * {tpl:counter}
     * output: 
     * 4
     * 7
     * 
     * {tpl:counter start=10 step=2 direction="down"}
     * {tpl:counter}
     * {tpl:counter}
     * output: 
     * 8
     * 6
    **/
    counter_ : function (rule, expr)
    {
        if ("counter" === expr)
        {
            this._context.push
            ({
                type : this.T.OUTPUT, 
                assign : this._assign.current, 
                data : this._counter
            });
        }
        else
        {
            var attr = Attr.handle(expr, rule);
            
            if ("start" in attr)
            {
                this._counter = attr.start | 0;
            }
            
            if ("step" in attr)
            {
                this._counterStep = attr.step | 0;
            }
            
            if ("direction" in attr)
            {
                this._counterDirection = attr.direction.slice(1, -1) === "up" ? 1 : 0;
            }
            
            if ("assign" in attr)
            {
                this._context.push
                ({
                    type : this.T.ASSIGN, 
                    assign : attr.assign, 
                    value : this._counter
                });
            }
        }
        
        if (this._counterDirection === 1)
        {
            this._counter += this._counterStep;
        }
        else
        {
            this._counter -= this._counterStep;
        }
    }, 
    
    /**
     * var data = [1, "red", 2, "yellow", 3, "green", 4, "blue"];
     * 
     * {tpl:each input=data value=val step=2}
     * number: {tpl:echo val} - {tpl:cycle values="yellow,green"}
     * {tpl:endeach}
     * output: 
     * number: 1 - yellow
     * number: 2 - green
     * number: 3 - yellow
     * 
     * {tpl:each input=data step=2}
     * {tpl:cycle values="yellow,green" assign=cval}
     * {tpl:endeach}
     * {tpl:echo cval}
     * output: 
     * yellow,green,yellow,green
    **/
    cycle_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        var T = this.T;
        var delimiter = "delimiter" in attr ? attr.delimiter : this._defaultCycleDelimiter;
        var values = attr.values.slice(1, -1).split(delimiter);
        
        "assign" in attr && this._assign.push(attr.assign);
        
        var cycleValueName = this._defaultCycleName + "V" + this._cycleIndex;
        this._context.push
        ({
            type : T.BEFORE_ASSIGN, 
            assign : cycleValueName, 
            value : JSON.stringify(values)
        });
        
        var cycleStartName = this._defaultCycleName + "S" + this._cycleIndex;
        this._context.push
        ({
            type : T.BEFORE_ASSIGN, 
            assign : cycleStartName, 
            value : 0
        });
        
        var cycleLengthName = this._defaultCycleName + "L" + this._cycleIndex;
        this._context.push
        ({
            type : T.BEFORE_ASSIGN, 
            assign : cycleLengthName, 
            value : values.length
        });
        
        this._context.push
        ({
            type : T.CODE, 
            code : cycleStartName + "===" + cycleLengthName + "&&" + "(" + cycleStartName + "=0);"
        });
        
        if ("assign" in attr)
        {
            this._context.push
            ({
                type : T.ASSIGN, 
                assign : attr.assign, 
                value : cycleValueName + "[" + cycleStartName + "++]"
            });
        }
        else
        {
            this._context.push
            ({
                type : T.ECHO, 
                assign : this._assign.current, 
                code : cycleValueName + "[" + cycleStartName + "++]"
            });
        }
        
        this._cycleIndex++;
    }, 
    
    /**
     * {tpl:literal}
     * <div>{tpl:echo data}</div>
     * {tpl:endliteral}
     * output: 
     * <div>{tpl:echo data}</div>
    **/
    literal_ : function (rule, list)
    {
        var cmd, item, index, T = this.T;
        
        while (item = list.nextToken())
        {
            if (item.type === list.T.TPL)
            {
                index = Math.max(item.value.indexOf(" "), item.value.indexOf("\t"));
                cmd = ~index ? item.value.slice(0, index) : item.value;
                
                if ("endliteral" === cmd)
                {
                    return;
                }
                
                item.value = list._tagsStart + item.value + list._tagsEnd;
            }
            
            this._context.push({type : T.OUTPUT, assign : this._assign.current, data : item.value});
        }
        
        this.throwError_(rule);
    }, 
    
    endliteral_ : function (rule)
    {
        this.throwError_(rule);
    }, 
    
    /**
     * {tpl:capture assign=data}
     * <div class="data">text...</div>
     * {tpl:endcapture}
     * {tpl:echo data,data}
     * output: 
     * <div class="data">text...</div>
     * <div class="data">text...</div>
    **/
    capture_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        !("assign" in attr) && this.throwError_(rule);
        this._context.push
        ({
            type : this.T.ASSIGN, 
            assign : attr.assign, 
            value : "\"\""
        });
        
        this._assign.push(attr.assign);
        this._capture.push(this.S.CAPTURE);
        this._captureRule.push(rule);
    }, 
    
    endcapture_ : function (rule)
    {
        this._assign.pop();
        this._capture.pop() !== this.S.CAPTURE && this.throwError_(rule);
        this._captureRule.pop();
    }, 
    
    /**
     * var a = 1, b = 2, c = 3;
     * 
     * {tpl:if a > b}
     * <div style="color:red">{tpl:echo a}</div>
     * {tpl:elseif b > c}
     * <div style="color:blue">{tpl:echo b}</div>
     * {tpl:else}
     * <div style="color:green">{tpl:echo c}</div>
     * {tpl:endif}
     * output: 
     * <div style="color:green">3</div>
    **/
    if_ : function (rule, expr)
    {
        this._context.push
        ({
            type : this.T.CODE, 
            code : "if(" + expr + "){"
        });
        
        this._if.push(this.S.ELSEIF);
        this._ifRule.push(rule);
    }, 
    
    elseif_ : function (rule, expr)
    {
        this._context.push
        ({
            type : this.T.CODE, 
            code : "}else if(" + expr + "){"
        });
        
        this._if.pop() !== this.S.ELSEIF && this.throwError_(rule);
        this._ifRule.pop();
        
        this._if.push(this.S.ELSEIF);
        this._ifRule.push(rule);
    }, 
    
    else_ : function (rule)
    {
        this._context.push
        ({
            type : this.T.CODE, 
            code : "}else{"
        });
        
        !(this._if.pop() === this.S.ELSEIF) && this.throwError_(rule);
        this._ifRule.pop();
        
        this._if.push(this.S.ELSE);
        this._ifRule.push(rule);
    }, 
    
    endif_ : function (rule)
    {
        this._context.push
        ({
            type : this.T.CODE, 
            code : "}"
        });
        
        var state = this._if.pop();
        this._ifRule.pop();
        !(state === this.S.ELSEIF || state === this.S.ELSE) && this.throwError_(rule);
    }, 
    
    /**
     * var data = 
     * {
     *     "info" : {"name" : "lzx", "gender" : "male", "age" : 23}, 
     *     "other" : {"address": "china"}
     * }
     * 
     * {tpl:loop input=data key=key}
     * key : {tpl:echo key}
     * {tpl:endloop}
     * output: 
     * info
     * other
     * 
     * {tpl:loop input=data key=ckey value=cval}
     * category: {tpl:echo ckey}
     *   {tpl:loop input=cval key=dkey value=dval}
     *   {tpl:echo dkey} => {tpl:echo dval}
     *   {tpl:endloop}
     * {tpl:endloop}
     * output: 
     * category: info
     *   name => lzx
     *   gender => male
     *   age => 23
     * category: other
     *   address => china
    **/
    loop_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        !("input" in attr) && this.throwError_(rule);
        
        var loopKeyName = "key" in attr ? attr.key : this._defaultLoopName + "K" + this._loopIndex;
        this._context.push
        ({
            type : this.T.DECLARE, 
            assign : loopKeyName
        });
        
        if ("value" in attr)
        {
            this._context.push
            ({
                type : this.T.DECLARE, 
                assign : attr.value
            });
            
            this._context.push
            ({
                type : this.T.CODE, 
                code : "for(" + loopKeyName + " in " + attr.input + ")" 
                  + "{" + attr.value + "=" + attr.input + "[" + loopKeyName + "];"
            });
        }
        else
        {
            this._context.push
            ({
                type : this.T.CODE, 
                code : "for(" + loopKeyName + " in " + attr.input + "){" 
            });
        }
        
        this._loop.push(this.S.LOOP);
        this._loopRule.push(rule);
        this._loopIndex++;
    }, 
    
    endloop_ : function (rule)
    {
        this._context.push
        ({
            type : this.T.CODE, 
            code : "}"
        });
        
        !(this._loop.pop() === this.S.LOOP) && this.throwError_(rule);
        this._loopRule.pop();
    }, 
    
    /**
    * {tpl:for start=0 end=5 index=i step=1}
    * {tpl:echo i}
    * {tpl:endfor}
    * 输出: 
    * 0
    * 1
    * 2
    * 3
    * 4
    **/
    for_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        !("end" in attr) && this.throwError_(rule);
        
        var T = this.T;
        
        var forStartName = "index" in attr ? attr.index : this._defaultForName + "S" + this._forIndex;
        this._context.push
        ({
            type : T.ASSIGN, 
            assign : forStartName, 
            value : "start" in attr ? attr.start | 0 : this._forStart
        });
        
        var forStepName = this._defaultForName + "SP" + this._forIndex;
        this._context.push
        ({
            type : T.ASSIGN, 
            assign : forStepName, 
            value : "step" in attr ? attr.step | 0 : this._forStep
        });
        
        var forEndName = this._defaultForName + "E" + this._forIndex;
        this._context.push
        ({
            type : T.ASSIGN, 
            assign : forEndName, 
            value : isNaN(attr.end) ? attr.end : attr.end | 0
        });
        
        this._context.push
        ({
            type : this.T.CODE, 
            code : "for(;" + forStartName + "<" + forEndName + ";" + forStartName + "+=" + forStepName + "){" 
        });
        
        this._for.push(this.S.FOR);
        this._forRule.push(rule);
        this._forIndex++;
    }, 
    
    endfor_ : function (rule)
    {
        this._context.push
        ({
            type : this.T.CODE, 
            code : "}"
        });
        
        !(this._for.pop() === this.S.FOR) && this.throwError_(rule);
        this._forRule.pop();
    }, 
    
    /**
     * var data = [1, "red", 2, "yellow", 3, "green", 4, "blue"];
     * 
     * {tpl:each input=data start=1 value=val step=2}
     * color: {tpl:echo val}
     * {tpl:endeach}
     * output: 
     * color: red
     * color: yellow
     * color: green
     * color: blue
     * 
     * {tpl:each input=data value=val step=2}
     * number: {tpl:echo val}
     * {tpl:endeach}
     * output: 
     * number: 1
     * number: 2
     * number: 3
     * number: 4
     * 
     * {tpl:each input=data start=-4 value=val}
     * {tpl:echo val}
     * {tpl:endeach}
     * output: 
     * 3
     * green
     * 4
     * blue
    **/
    each_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        !("input" in attr) && this.throwError_(rule);
        
        var T = this.T;
        
        var eachStartName = "index" in attr ? attr.index : this._defaultEachName + "S" + this._eachIndex;
        this._context.push
        ({
            type : T.ASSIGN, 
            assign : eachStartName, 
            value : "start" in attr ? attr.start | 0 : this._eachStart
        });
        
        var eachStepName = this._defaultEachName + "SP" + this._eachIndex;
        this._context.push
        ({
            type : T.ASSIGN, 
            assign : eachStepName, 
            value : "step" in attr ? attr.step | 0 : this._eachStep
        });
        
        var eachLengthName = this._defaultEachName + "L" + this._eachIndex;
        this._context.push
        ({
            type : T.DECLARE, 
            assign : eachLengthName
        });
        
        "value" in attr && this._context.push({type : T.DECLARE, assign : attr.value});
        var valueName = "value" in attr ? attr.value + "=" + attr.input + "[" + eachStartName + "];" : "";
        
        this._context.push
        ({
            type : this.T.CODE, 
            code : eachLengthName + "=" + attr.input + ".length;"
              + "if(" + eachStartName + "<0)" + eachStartName + "=Math.max(" + eachLengthName + "+" + eachStartName + ",0);"
              + "for(;" + eachStartName + "<" + eachLengthName + ";" + eachStartName + "+=" + eachStepName + ")"
              + "{" + valueName
        });
        
        this._each.push(this.S.EACH);
        this._eachRule.push(rule);
        this._eachIndex++;
    }, 
    
    endeach_ : function (rule)
    {
        this._context.push
        ({
            type : this.T.CODE, 
            code : "}"
        });
        
        !(this._each.pop() === this.S.EACH) && this.throwError_(rule);
        this._eachRule.pop();
    }, 
    
    /**
     * {tpl:lang assign=fruit type=langType file="fruit.json"}
     * {tpl:echo langType, ": ", fruit.apple}
     * output:
     * zh-cn: 苹果
     * 
     * {tpl:lang assign=tool file="tool.json"}
     * {tpl:echo tool.book}
     * output:
     * 书
     * 
     * {tpl:lang list=langList}
     * {tpl:loop input=langList key=name value=value}
     * {tpl:echo name, " : ", value}
     * {tpl:endloop}
     * 输出: 
     * zh-cn : 简体中文
     * zh-tw : 繁體中文
     * en : English
    **/
    lang_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        if ("name" in attr)
        {
            this._context.push
            ({
                type : this.T.ASSIGN, 
                assign : attr.name, 
                value : "_LANG_.getLanguageName()"
            });
        }
        
        if ("type" in attr)
        {
            this._context.push
            ({
                type : this.T.ASSIGN, 
                assign : attr.type, 
                value : "_LANG_.getLanguage()"
            });
        }
        
        if ("list" in attr)
        {
            this._context.push
            ({
                type : this.T.ASSIGN, 
                assign : attr.list, 
                value : "_LANG_.getLanguageList()"
            });
        }
        
        if ("file" in attr)
        {
            this._context.push
            ({
                type : this.T.CODE, 
                code : "_LANG_.use(" + attr.file + ");"
            });
        }
        
        var section = "";
        
        if ("section" in attr)
        {
            var ch = attr.section.charCodeAt();
            if (ch === this.A.SQUOTE || ch === this.A.DQUOTE)
            {
                section = "." + attr.section.slice(1, -1);
            }
            else
            {
                section = "[" + attr.section + "]";
            }
        }
        
        if ("assign" in attr)
        {
            this._context.push
            ({
                type : this.T.ASSIGN, 
                assign : attr.assign, 
                value : attr.assign + "=_LANG_.current" + section + ";"
            });
        }
    }, 
    
    /**
     * {tpl:function assign=url call=link(
     *   {controller : "articleController", action : "readAction", module : "Default"}, 
     *   {page : 2, id : 1000})}
     * {tpl:echo url}
     * output:
     * /article/read/2/10000
     * 
     * {tpl:function call=link("/article/read/:page/:id", {page : 2, id : 1000, token : "xxx"})}
     * output:
     * /article/read/2/10000?token=xxx
     * 
     * more...
     * 
    **/
    function_ : function (rule, expr)
    {
        var attr = Attr.handle(expr, rule);
        
        !("call" in attr) && this.throwError_(rule);
        
        var call = attr.call;
        var offset, index = 0;
        
        offset = call.indexOf("(");
        var funcName = call.slice(index, offset);
        !(funcName in this._callFunctionList) && this.throwError_(rule);
        
        index = offset + 1;
        offset = call.indexOf(")", index);
        !~offset && this.throwError_(rule);
        var callCode = call.slice(index, offset);
        
        if ("assign" in attr)
        {
            this._context.push
            ({
                type : this.T.ASSIGN, 
                assign : attr.assign, 
                value : this._callFunctionList[funcName].replace("#code#", callCode)
            });
        }
        else
        {
            this._context.push
            ({
                type : this.T.ECHO, 
                assign : this._assign.current, 
                code : this._callFunctionList[funcName].replace("#code#", callCode)
            });
        }
    }, 
    
    throwError_ : function (rule)
    {
        if (true)
        {
            throw new Error("Please check [" + rule.file + "] on line " + (rule.line + 1));
        }
    }, 
    
    getTplPath_ : function (fileName)
    {
        return this._directory + "/View/" + fileName;
    }, 
    
    getTplData_ : function (fileName)
    {
        return fs.readFileSync(this.getTplPath_(fileName), "utf8");
    }
};

module.exports = Compiler;