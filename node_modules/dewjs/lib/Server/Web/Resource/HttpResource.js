/**
 * @author     LiuZhaoHui <hi.liuzhaoxin@gmail.com>
 * @link       http://www.eatbean.com/nodejs
**/

"use strict";

var fs = require("fs");
var zlib = require("zlib");
var LString = Dew("use", "Lang.LString");

var Mime = Dew("use", "Server.Web.Resource.Mime");
var Range = Dew("use", "Server.Web.Resource.Range");
var Cache = Dew("use", "Server.Web.Resource.Cache");

/*
{
    "url" : "/gzip/", 
    "suffix" : ["js", "css", "html", "jpg", "exe"], 
    "allow" : ["compress", "cache"], 
    "headers" : {"Age" : "180"}
}
*/

var HttpResource = 
{
    __name__ : "HttpResource", 
    
    initialize : function (application)
    {
        Cache.initialize(application);
        
        application.useSection("paths");
        this._resourceDir = application.get("startupPath") 
          + "/" + application.get("resourcePath");
        
        application.useSection("http");
        this._directoryIndex = application.get("directory_index");
        this._compressMethod = application.get("http_compress_method");
        this._supportRange = application.get("http_range");
        this._cacheTime = application.get("http_cache_time");
        this._exposeNodejs = application.get("expose_nodejs");
        this._cacheControl = "public, max-age=" + this._cacheTime;
        this._defaultCharset = "; charset=" + application.get("default_charset");
    }, 
    
    dispatch : function (request, response, url, dir, suffix)
    {
        var self = Object.create(this);
        
        if (~url.indexOf("\0")) return self.sendError(response, 400);
        
        self._url = url;
        self._dir = dir;
        self._suffix = suffix;
        self._filepath = this._resourceDir + url;
        self._request = request;
        self._response = response;
        
        fs.stat(self._filepath, self.handle.bind(self));
    }, 
    
    handle : function (err, stat)
    {
        if (err) return this.sendError(404);
        else if (stat.isDirectory()) return this.redirect();
        
        var result = Cache.match(this._dir, this._suffix);
        if (result) return this.handleCache(result, stat);
        
        if (!this.sendFullHeader(stat)) return;
        this.sendFile(stat.size);
    }, 
    
    handleCache : function (result, stat)
    {
        if ("headers" in result)
        {
            var key, headers = result.headers;
            
            for (key in headers)
            {
                this._response.setHeader(key, headers[key]);
            }
        }
        
        if ("cache" in result)
        {
            var cache = result.cache, url = this._url;
            
            if (url in cache)
            {
                return this.sendBuffer(cache[url]);
            }
            
            cache = cache[url] = {mtime : stat.mtime, oSize : stat.size};
            
            try {
                var buf = fs.readFileSync(this._filepath);
            } catch (e) {
                return this.sendError(500);
            }
            
            if (result.isCompress)
            {
                if ("gzip" === this._compressMethod)
                {
                    return zlib.gzip(buf, this.compressCache.bind(this, cache));
                }
                else if ("deflate" === this._compressMethod)
                {
                    return zlib.deflate(buf, this.compressCache.bind(this, cache));
                }
            }
            else
            {
                cache.size = buf.length;
                cache.buf = buf;
                cache.isCompress = false;
                return this.sendBuffer(cache);
            }
        }
        else if (result.isCompress)
        {
            return this.compressFile(stat);
        }
        
        if (!this.sendFullHeader(stat)) return;
        this.sendFile(stat.size);
    }, 
    
    redirect : function ()
    {
        this._response.statusCode = 301;
        this._response.setHeader("Location", this._url + "/" + this._directoryIndex);
        this._response.end();
    }, 
    
    compressCache : function (cache, err, buf)
    {
        if (err) return this.sendError(500);
        
        cache.size = buf.length;
        cache.buf = buf;
        cache.isCompress = true;
        this.sendBuffer(cache);
    }, 
    
    sendBuffer : function (cache)
    {
        if (!this.sendFullHeader(cache)) return;
        if (cache.isCompress && !this.sendCompressHeader()) return this.sendFile(cache.oSize);
        
        var options = this.sendRangeHeader(cache.size);
        
        if (!options) return;
        
        this._response.end(cache.buf.slice(options.start, options.end), "binary");
    }, 
    
    compressFile : function (stat)
    {
        if (!this.sendFullHeader(stat)) return;
        if (!this.sendCompressHeader()) return this.sendFile(stat.size);
        
        var stream = fs.createReadStream(this._filepath);
        
        if (this._compressMethod === "gzip")
        {
            stream = stream.pipe(zlib.createGzip());
        }
        else if (this._compressMethod === "deflate")
        {
            stream = stream.pipe(zlib.createDeflate());
        }
        
        return this.sendStream(stream);
    }, 
    
    sendFile : function (size)
    {
        var options = this.sendRangeHeader(size);
        if (!options) return;
        
        this.sendStream(fs.createReadStream(this._filepath, options));
    }, 
    
    sendStream : function (stream)
    {
        stream.pipe(this._response);
        this._request.on("close", stream.destroy.bind(stream));
        stream.on("error", this._request.destroy.bind(this._request));
    }, 
    
    sendError : function (status)
    {
        this._response.statusCode = status;
        this._response.end();
    }, 
    
    sendRangeHeader : function (fileSize)
    {
        if (this._supportRange)
        {
            this._response.setHeader("Accept-Ranges", "bytes");
            
            if ("range" in this._request.headers)
            {
                var options = Range.parseRange(this._request.headers.range, fileSize - 1); 
                
                if (options.isRange)
                {
                    this._response.statusCode = 206;
                    this._response.setHeader("Content-Range", 
                      "bytes " + options.start + "-" + options.end++ + "/" + fileSize);
                    this._response.setHeader("Content-Length", options.end - options.start)
                    
                    return options;
                }
                else
                {
                    this._response.statusCode = 416;
                    this._response.setHeader("Content-Range", "bytes */" + fileSize);
                    this._response.end();
                    
                    return null;
                }
            }
        }
        
        this._response.setHeader("Content-Length", fileSize);
        return {start : 0, end : fileSize};
    }, 
    
    sendCompressHeader : function ()
    {
        if ("accept-encoding" in this._request.headers 
          && ~this._request.headers["accept-encoding"].indexOf(this._compressMethod))
        {
            if (this._compressMethod === "gzip")
            {
                this._response.setHeader("Content-Encoding", "gzip");
            }
            else if (this._compressMethod === "deflate")
            {
                this._response.setHeader("Content-Encoding", "deflate");
            }
            else
            {
                return false;
            }
            
            return true;
        }
        
        return false;
    }, 
    
    sendFullHeader : function (stat)
    {
        this._exposeNodejs && this._response.setHeader("Server", Dew.server);
        
        this._response.setHeader("Cache-Control", this._cacheControl);
        this._response.setHeader("Age", this._cacheTime);
        
        var time = new Date();
        // Node.js 会自动发送 Date 报头
        //this._response.setHeader("Date", time.toUTCString());
        this._response.setHeader("Expires", (time.setTime(+time + this._cacheTime * 1000), time.toUTCString()));
        
        var eTag = "\"" + stat.mtime.getTime().toString(16) + ":" + stat.size.toString(16) + "\"";
        this._response.setHeader("ETag", eTag);
        
        var lastModified = stat.mtime.toUTCString();
        this._response.setHeader("Last-Modified", lastModified);
        
        var type = Mime.lookup(this._suffix);
        this._response.setHeader("Content-Type", LString.startsWith(type, "text") ? type + this._defaultCharset : type);
        
        if (/* this.isCachable() && */ this.isFresh(eTag, lastModified)) return this.notModified();
        
        return true;
    }, 
    
    /*
    isCachable : function ()
    {
        var code = this._response.statusCode;
        // responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
        return (code >= 200 && code < 300) || 304 == code;
    }, 
    */
    
    isFresh : function (eTag, lastModified)
    {
        var noneMatch = this._request.headers["if-none-match"];
        
        // ETag => If-None-Match
        if (noneMatch && eTag === noneMatch) return true;
        
        var modifiedSince = this._request.headers["if-modified-since"];
        
        // Last-Modified => If-Modified-Since
        if (modifiedSince && lastModified === modifiedSince) return true;
        
        return false;
    }, 
    
    notModified : function ()
    {
        this._response.statusCode = 304;
        this._response.end();
        
        return false;
    }
};

module.exports = HttpResource;