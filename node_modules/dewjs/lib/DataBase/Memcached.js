/**
 * @author     LiuZhaoHui <hi.liuzhaoxin@gmail.com>
 * @link       http://www.eatbean.com/nodejs
**/

"use strict";

var LString = Dew("use", "Lang.LString");

var Query = Dew("use", "DataBase.Memcached.Query");
var PersistentQuery = Dew("use", "DataBase.Memcached.PersistentQuery");
var Connect = Dew("use", "DataBase.Memcached.Connect");

/*
var mc = Object.create(Memcached);
mc.pconnect();
mc.set(...);
mc.get(...);
mc.pclose();
*/

var Memcached = 
{
    __name__ : "Memcached", 
    
    _servers : {}, 
    
    initialize : function (application)
    {
        if ("_isinitialize" in this) return;
        this._isinitialize = true;
        
        Query.initialize(application);
        Connect.initialize(application);
        
        application.useSection("memcached");
        var servers = application.get("connect");
        var i = 0, len = servers.length;
        
        for (; i < len; i++)
        {
            this.addServer(servers[i]);
        }
        
        len && this.use(servers[0].id);
    }, 
    
    // 返回一个 Memcached 实例
    getInstance : function (id)
    {
        var self = Object.create(this);
        undefined !== id && self.use(id);
        
        return self;
    }, 
    
    use : function (id)
    {
        if (!(id in this._servers))
        {
            throw new Error("Memcached: id is \"" + id + "\" server does not exist");
        }
        
        this._current = this._servers[id];
    }, 
    
    // 添加服务器
    // {"id" : "mc1", "host" : "127.0.0.1", "port" : 11211}
    addServer : function (param)
    {
        this._servers[param.id] = Query.getInstance(Connect.getInstance(param));
    }, 
    
    // 持久连接
    pconnect : function ()
    {
        // 当前对象不允许直接使用持久连接
        // 若需持久连接，代码如下
        // var mc = Object.create(Memcached);
        // mc.pconnect();
        // 用完后切记关闭持久连接，否则会造成连接一直处于闲置
        // mc.pclose();
        if ("openPersistentQuery" in this || this === Memcached) return;
        this._current = new PersistentQuery(this._current).openPersistentQuery();
    }, 
    
    // 持久关闭
    pclose : function ()
    {
        if (!("closePersistentQuery" in this._current)) return;
        this._current = this._current.closePersistentQuery();
    }, 
    
    // 取得一个或多个值
    get : function (key, callback)
    {
        this._current.addQuery("get " + key + "\r\n", callback);
    }, 
    
    // 取得一个或多个值，并包含 cas_token 值
    gets : function (key, callback)
    {
        this._current.addQuery("gets " + key + "\r\n", callback);
    }, 
    
    // 储存此数据
    set : function (key, val, callback, expiration)
    {
        val = val.toString();
        var cmd = "set " + key + " 0 " + (expiration | 0) 
          + " " + LString.sizeof(val) + "\r\n" + val + "\r\n";
        
        this._current.addQuery(cmd, callback);
    }, 
    
    // 储存此数据，只在服务器不存在此键值的数据时
    add : function (key, val, callback, expiration)
    {
        val = val.toString();
        var cmd = "add " + key + " 0 " + (expiration | 0) 
          + " " + LString.sizeof(val) + "\r\n" + val + "\r\n";
        
        this._current.addQuery(cmd, callback);
    }, 
    
    // 储存此数据，只在服务器已存在此键值的数据时
    repalce : function (key, val, callback, expiration)
    {
        val = val.toString();
        var cmd = "repalce " + key + " 0 " + (expiration | 0) 
          + " " + LString.sizeof(val) + "\r\n" + val + "\r\n";
        
        this._current.addQuery(cmd, callback);
    }, 
    
    // 储存此数据，只在服务器已存在此键值的数据时在原值后添加
    append : function (key, val, callback, expiration)
    {
        val = val.toString();
        var cmd = "append " + key + " 0 " + (expiration | 0) 
          + " " + LString.sizeof(val) + "\r\n" + val + "\r\n";
        
        this._current.addQuery(cmd, callback);
    }, 
    
    // 储存此数据，只在服务器已存在此键值的数据时在原值前添加
    prepend : function (key, val, callback, expiration)
    {
        val = val.toString();
        var cmd = "prepend " + key + " 0 " + (expiration | 0) 
          + " " + LString.sizeof(val) + "\r\n" + val + "\r\n";
        
        this._current.addQuery(cmd, callback);
    }, 
    
    // 检查并储存此数据
    cas : function (cas_token, key, val, callback, expiration)
    {
        val = val.toString();
        var cmd = "cas " + key + " 0 " + (expiration | 0) 
          + " " + LString.sizeof(val) + " " + cas_token + "\r\n" + val + "\r\n";
        
        this._current.addQuery(cmd, callback);
    }, 
    
    // 递增
    increment : function (key, val, callback)
    {
        this._current.addQuery("incr " + key + " " + val + "\r\n", callback);
    }, 
    
    // 递减
    decrement : function (key, val, callback)
    {
        this._current.addQuery("decr " + key + " " + val + "\r\n", callback);
    }, 
    
    // 修改过期时间
    touch : function (key, val, callback)
    {
        this._current.addQuery("touch " + key + " " + val + "\r\n", callback);
    }, 
    
    // 获取服务器状态
    stats : function (callback)
    {
        this._current.addQuery("stats\r\n", callback);
    }, 
    
    // 获取服务器版本
    version : function (callback)
    {
        this._current.addQuery("version\r\n", callback);
    }, 
    
    // 将所有对象置为不可获取状态
    flush : function (callback, time)
    {
        this._current.addQuery("flush_all" + (time === undefined ? "" : " " + time) + "\r\n", callback);
    }, 
    
    // 删除指定键名的内容
    del : function (key, callback)
    {
        this._current.addQuery("delete " + key + "\r\n", callback);
    }
};

module.exports = Memcached;